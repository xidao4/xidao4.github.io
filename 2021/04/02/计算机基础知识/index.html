<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>计算机基础知识 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="数据库事务满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 Atomicity原子性：事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚Consistency一致性：数据库在事务执行前后都保持一致性状态。Isolation隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。Durability持">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机基础知识">
<meta property="og:url" content="http://example.com/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据库事务满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 Atomicity原子性：事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚Consistency一致性：数据库在事务执行前后都保持一致性状态。Isolation隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。Durability持">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/99590/AppData/Roaming/Typora/typora-user-images/image-20210401102408553.png">
<meta property="og:image" content="c:/Users/99590/AppData/Roaming/Typora/typora-user-images/image-20210401143230012.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/java-collection-hierarchy.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png">
<meta property="og:image" content="c:/Users/99590/AppData/Roaming/Typora/typora-user-images/image-20210329171343653.png">
<meta property="article:published_time" content="2021-04-02T02:24:48.000Z">
<meta property="article:modified_time" content="2021-05-05T14:08:06.726Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/99590/AppData/Roaming/Typora/typora-user-images/image-20210401102408553.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-计算机基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-02T02:24:48.000Z" itemprop="datePublished">2021-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      计算机基础知识
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<p>Atomicity原子性：事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚<br>Consistency一致性：数据库在事务执行前后都保持一致性状态。<br>Isolation隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。<br>Durability持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。</p>
<h4 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h4><p>丢失修改：T1事务对一个数据进行修改，还没提交，T2事务也修改，覆盖了T1的修改。<br>读脏数据：T1修改数据但未提交，T2读取了这个数据，但T1撤销了修改<br>不可重复读：T1在一次事务中多次读取数据，但T2在两次读取中间修改了数据，导致T1两次读到的数据不同<br>幻读：T1在一次事务中多次读取某个范围的数据，但T2在两次读取中间插入了新数据，导致T1两次读到的数据不同</p>
<h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><p>一级封锁协议：解决丢失修改问题。修改数据必须加X锁，直到事务结束才释放锁。<br>二级封锁协议：解决脏读问题。读数据必须加S锁，读完马上释放锁。<br>三级封锁协议：解决不可重复读问题。读数据必须加S锁，事务结束才释放锁。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>读取未提交<br>读取已提交：解决脏读<br>可重复读：解决不可重复读<br>可串行化：解决幻读</p>
<h4 id="多版本并发控制MVCC"><a href="#多版本并发控制MVCC" class="headerlink" title="多版本并发控制MVCC"></a>多版本并发控制MVCC</h4><p>实现隔离级别的一种具体方式。<br>写操作更新最新的版本快照，读操作读旧版本快照，只能读取已经提交的快照。事务的修改操作DELETE INSERT UPDATE会为数据行新增一个版本快照。</p>
<h4 id="快照读-amp-当前读"><a href="#快照读-amp-当前读" class="headerlink" title="快照读&amp;当前读"></a>快照读&amp;当前读</h4><p>MVCC的select操作是快照的数据，不需要进行加锁</p>
<p>但是INSERT UPDATE DELETE需要加锁。</p>
<h4 id="next-key-locks"><a href="#next-key-locks" class="headerlink" title="next-key locks"></a>next-key locks</h4><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>封锁粒度：行级锁、表级锁</p>
<p>封锁类型：</p>
<p>互斥锁 X锁 写锁</p>
<p>共享锁 S锁 读锁</p>
<p>意向锁</p>
<p>IX/IS 都是表锁，表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+ 树有更低的树高。平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p>
<p> B+ 树访问磁盘数据有更高的性能。进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>
<h4 id="innodb索引"><a href="#innodb索引" class="headerlink" title="innodb索引"></a>innodb索引</h4><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<p>索引：对某一列或多个列的值进行预排序的数据结构。<br>不必全表扫描，只需要搜索树，这样就大大加快了查询速度。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。</p>
<p>聚集索引：聚集索引确定表中数据的物理顺序。叶子节点 data 域记录着完整的数据记录。<br>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<ul>
<li>数据类型</li>
</ul>
<p>数值、时间、字符串</p>
<h4 id="用ID做主键的好处"><a href="#用ID做主键的好处" class="headerlink" title="用ID做主键的好处"></a>用ID做主键的好处</h4><h4 id="查询语句如何找到内容"><a href="#查询语句如何找到内容" class="headerlink" title="查询语句如何找到内容"></a>查询语句如何找到内容</h4><ol>
<li><p>分析器</p>
<p>词法分析，语法分析，生成一个语法树</p>
</li>
<li><p>优化器</p>
<p>从数据字典中获取许多<strong>统计信息</strong>，对语法分析树的形态进行修改，把语法分析树变为查询树</p>
</li>
<li><p>执行器</p>
<p>调用引擎的接口</p>
</li>
</ol>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><img src="C:\Users\99590\AppData\Roaming\Typora\typora-user-images\image-20210401102408553.png" alt="image-20210401102408553"></p>
<h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p>加载：加载类的二进制文件（class文件）。方法区：类的类信息，堆：class文件对应的类实例<br>验证：确保加载的类信息正确<br>准备：为类的静态变量分配空间，赋初值<br>解析：将符号引用转换为直接引用。a=”10”中的a转换为地址<br>初始化：对静态变量赋予正确值</p>
<h4 id="对象的垃圾判断算法"><a href="#对象的垃圾判断算法" class="headerlink" title="对象的垃圾判断算法"></a>对象的垃圾判断算法</h4><p>引用计数</p>
<p>根可达算法</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
</ul>
<h4 id="类的垃圾判断方法（类的卸载条件）"><a href="#类的垃圾判断方法（类的卸载条件）" class="headerlink" title="类的垃圾判断方法（类的卸载条件）"></a>类的垃圾判断方法（类的卸载条件）</h4><p>需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法</li>
</ul>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p>标记清除、标记复制、标记整理算法<br>分代收集算法</p>
<h4 id="从新生代转到老生代"><a href="#从新生代转到老生代" class="headerlink" title="从新生代转到老生代"></a>从新生代转到老生代</h4><p>如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄</p>
<h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<p><img src="C:\Users\99590\AppData\Roaming\Typora\typora-user-images\image-20210401143230012.png" alt="image-20210401143230012"></p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h4 id="集合继承图"><a href="#集合继承图" class="headerlink" title="集合继承图"></a>集合继承图</h4><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/java-collection-hierarchy.png" alt="image-20210310205140232"></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li>
<li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li>
</ul>
<p>InputStream input=MultipartFile file.getInputStream() catch IOException</p>
<p>Date start=dateFormat.parse(String checkInDate)  catch ParseException<br>如果字符串和构造方法的模式不一样，则程序抛出异常</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>JVM为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class</code>实例来保存<code>class</code>及<code>interface</code>的所有信息；获取一个<code>class</code>对应的<code>Class</code>实例后，就可以获取该<code>class</code>的所有信息；通过Class实例获取<code>class</code>信息的方法称为反射；</p>
<p>利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。</p>
<p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls &#x3D; String.class;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; &quot;Hello&quot;;</span><br><span class="line">Class cls &#x3D; s.getClass();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls &#x3D; Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure>

<p><code>Class</code>实例在JVM中是唯一的</p>
<p>通过class实例可以获取的class信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class name: java.lang.String</span><br><span class="line">Simple name: String</span><br><span class="line">Package name: java.lang</span><br><span class="line">is interface: false</span><br><span class="line">is enum: false</span><br><span class="line">is array: false</span><br><span class="line">is primitive: false</span><br></pre></td></tr></table></figure>



<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实例，转型为接口并调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello hello = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种方式就是我们通常编写代码的方式。</p>
<p>没有实现类但是在运行期动态创建了一个接口的对象（实例）。通过<code>Proxy</code>创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>完成的。</p>
<ol>
<li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li>
<li>通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：<ol>
<li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去；</li>
<li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li>
</ol>
</li>
<li>将返回的<code>Object</code>强制转型为接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型就是编写模板代码来适应任意类型；</p>
<p>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</p>
<p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>
<p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p>
<p>Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p>
<h4 id="Java与C"><a href="#Java与C" class="headerlink" title="Java与C"></a>Java与C</h4><ul>
<li>编译与跨平台</li>
</ul>
<p>c++源码编译以后，生成的是特定机器可以直接运行的文件。（<strong>源文件</strong>—编译—汇编—&gt;<strong>目标文件</strong>—与库文件链接—&gt;<strong>可执行文件</strong>）<br>Java源码经过编译后，生成的是中间的字节码文件，这些字节码文件放在JVM中运行的，JVM有多个平台版本。<br>因此，Java是具有跨平台的，而C++没有。</p>
<ul>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
<li>Java是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</li>
</ul>
<h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。.java源文件编译出的.class字节码，JVM生成可执行的二进制机器码。Java“一次编译，随处运行”，是因为JVM 有针对不同系统（Windows，Linux，macOS）的特定实现，相同字节码由于不同系统的JVM都会给出相同结果。</p>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>长生命周期的对象持有短生命周期对象的引用</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>boolean char byte short int long float double</p>
<p>char 在 Java 中占两个字节</p>
<p>overload重载<br>override重写</p>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>数据职责和行为职责在一起</p>
<p>单一职责原则：类的职责要单一，仅有一个引起它变化的原因。高内聚、低耦合。否则可复性很低。</p>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>
<p>子类可以重写父类方法。</p>
<p>里氏代换原则：所有使用基类对象的地方，一定能使用其子类对象。用处?</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<h5 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h5><p>没有对方法进行加同步锁，所以是非线程安全的</p>
<p>性能略好</p>
<h5 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h5><p>对方法加了同步锁，所以是线程安全的</p>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>
<h5 id="equals-hashcode"><a href="#equals-hashcode" class="headerlink" title="equals hashcode"></a>equals hashcode</h5><p>对于基本类型来说，== 比较的是值是否相等；</p>
<p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p>
<p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li>不建议在多线程下使用 HashMap，因为存在数据丢失的问题。<br>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。<br>并发环境下推荐使用ConcurrentHashMap。</li>
<li> Rehash 会造成元素之间会形成一个循环链表</li>
<li>对于上述四种Map类型的类，要求映射中的key是不可变对象，该对象在创建后它的哈希值不会被改变。</li>
</ul>
<h4 id="Hashtable-同一把锁"><a href="#Hashtable-同一把锁" class="headerlink" title="Hashtable(同一把锁)"></a><code>Hashtable</code>(同一把锁)</h4><p>使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>JDK1.7：分段的数组+链表。多线程访问容器里不同数据段的数据，就不会存在锁竞争</p>
<p>JDK1.8：Node数组+链表/TreeNode数组+红黑二叉树。并发控制使用 <code>synchronized</code> 和 CAS 来操作。<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发</p>
<h4 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h4><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/06/24/java-hashmap.html">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p>
<ul>
<li>HashMap 的长度为什么是2的幂次方</li>
</ul>
<p>采用二进制位操作 &amp;，相对于%能够提高运算效率</p>
<p>hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p>
<p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务。<br>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装<br>继承 Thread 类也需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<p>实现接口会更好一些，因为：</p>
<ul>
<li><p>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</p>
</li>
<li><p>类可能只要求可执行就行，继承整个 Thread 类开销过大</p>
</li>
</ul>
<p>Executor 管理多个异步任务的执行，多个任务的执行互不干扰，不需要进行同步操作，无需程序员显式地管理线程的生命周期。</p>
<p>线程的生命周期：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png"></p>
<p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程。<br>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。<br>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<p>用<code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用<code>this</code>实例加锁。<br>对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的。原因？</p>
<p>线程间通信就是读写同一个变量，速度很快</p>
<p>线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>
<p>对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作，即某一个线程执行时，其他线程必须等待。</p>
<p>看上去是一行语句，实际上对应了3条指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">n的值是100，如果两个线程同时执行n &#x3D; n + 1，得到的结果很可能不是102，而是101，原因在于：</span><br><span class="line">┌───────┐    ┌───────┐</span><br><span class="line">│Thread1│    │Thread2│</span><br><span class="line">└───┬───┘    └───┬───┘</span><br><span class="line">    │            │</span><br><span class="line">    │ILOAD (100) │</span><br><span class="line">    │            │ILOAD (100)</span><br><span class="line">    │            │IADD</span><br><span class="line">    │            │ISTORE (101)</span><br><span class="line">    │IADD        │</span><br><span class="line">    │ISTORE (101)│</span><br><span class="line">    ▼            ▼</span><br><span class="line">    </span><br><span class="line">┌───────┐     ┌───────┐</span><br><span class="line">│Thread1│     │Thread2│</span><br><span class="line">└───┬───┘     └───┬───┘</span><br><span class="line">    │             │</span><br><span class="line">    │-- lock --   │</span><br><span class="line">    │ILOAD (100)  │</span><br><span class="line">    │IADD         │</span><br><span class="line">    │ISTORE (101) │</span><br><span class="line">    │-- unlock -- │</span><br><span class="line">    │             │-- lock --</span><br><span class="line">    │             │ILOAD (101)</span><br><span class="line">    │             │IADD</span><br><span class="line">    │             │ISTORE (102)</span><br><span class="line">    │             │-- unlock --</span><br><span class="line">    ▼             ▼</span><br><span class="line">    </span><br><span class="line">即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</span><br></pre></td></tr></table></figure>

<p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）</p>
<p>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。<br>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p>
<p>死锁：互斥、持有等待、不可剥夺、循环等待</p>
<p>必须在<code>synchronized</code>块中才能调用<code>wait()</code>方法，因为<code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</p>
<p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。所以热entrant lock不会导致死锁</p>
<p>4.<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常，而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p>
<p>5.都是可重入锁，一个线程可以多次获取同一个锁。</p>
<p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p>
<p>使用<code>java.util.concurrent.atomic</code>提供的原子操作可以简化多线程编程：</p>
<ul>
<li>原子操作实现了无锁的线程安全；</li>
<li>适用于计数器，累加器等。</li>
</ul>
<p>基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>jvm的内存模型中，每个线程都有一块单独的内存区域，并且会存储共享变量的副本到线程私有的内存区域中。</p>
<p>进程是程序的一次执行过程</p>
<p>一个进程在其执行的过程中可以产生多个线程。系统在产生一个线程，或是在各个线程之间作切换工作时，开销要比进程小得多。多个线程共享进程的堆和方法区/元空间。</p>
<p>多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销，提高了CPU利用率</p>
<p><strong>内存泄漏</strong>、<strong>死锁</strong> </p>
<h4 id="实现线程的方式"><a href="#实现线程的方式" class="headerlink" title="实现线程的方式"></a>实现线程的方式</h4><p>1.继承Thread类重写run方法。</p>
<p>2.实现runnable接口，重写run方法</p>
<p>3.<strong>使用Callable接口创建线程。</strong></p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>让每个线程拥有自己的专属本地私有数据，访问这个变量的每个线程都会有这个变量的本地副本</p>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>sleep()是线程类Thread的静态方法，<br>会休眠当前正在执行的线程（等待超时状态），<br>但不会释放对象锁，到时间自动恢复；</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>wait()是Object的方法，<br>进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程<br>释放对象锁</p>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>是个关键字。synchronized可以加在方法上，也可以加在特定代码块中。<br>synchronized修饰的代码在执行异常时，jdk会自动释放线程占有的锁，不需要程序员去控制释放锁，因此不会导致死锁现象发生。<br>保证多个线程之间访问资源的同步性（互斥性），保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p>是个接口。需要显示指定起始位置和终止位置。一般使用ReentrantLock(悲观)类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。</p>
<p>实现类：AQS(AbstractQueuedSynchronizer)、ReentrantLock可重入锁、ReentrantReadWriteLock,CountDownLatch,Semphore。</p>
<h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><code>volatile</code> 关键字</h4><ol>
<li>防止 JVM 的指令重排。</li>
<li>保证变量的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
<li>指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li>
<li><code>volatile</code>性能比<code>synchronized</code>关键字要好。但是<code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块。</li>
</ol>
<h4 id="JAVA线程池"><a href="#JAVA线程池" class="headerlink" title="JAVA线程池"></a>JAVA线程池</h4><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 线程池核心线程大小,线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。</li>
<li>maximumPoolSize 线程池最大线程数量</li>
<li>keepAliveTime 空闲线程存活时间。一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定</li>
<li>unit 空闲线程存活时间单位，keepAliveTime的计量单位</li>
<li>workQueue 工作队列 新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。</li>
<li>threadFactory 线程工厂。创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>
<li>handler 拒绝策略</li>
</ul>
<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><p>三次握手</p>
<p>四次挥手</p>
<h4 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP HTTPS"></a>HTTP HTTPS</h4><p>HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>
<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>
<p>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</p>
<ul>
<li><p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p>
</li>
<li><p>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p>
</li>
</ul>
<p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li>
</ul>
<h4 id="长短连接"><a href="#长短连接" class="headerlink" title="长短连接"></a>长短连接</h4><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。每次请求都要重新建立一次连接。</p>
<p>从HTTP/1.1起，默认使用长连接，会在响应头开启Connection:keep-alive。<br>当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间</p>
<p><strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</p>
<h4 id="HTTP无状态"><a href="#HTTP无状态" class="headerlink" title="HTTP无状态"></a>HTTP无状态</h4><p> HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。<br>服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<h4 id="cookie被禁用"><a href="#cookie被禁用" class="headerlink" title="cookie被禁用"></a>cookie被禁用</h4><p>使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h4 id="使用-Session-维护用户登录状态的过程如下："><a href="#使用-Session-维护用户登录状态的过程如下：" class="headerlink" title="使用 Session 维护用户登录状态的过程如下："></a>使用 Session 维护用户登录状态的过程如下：</h4><ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<h4 id="在浏览器输入URL地址"><a href="#在浏览器输入URL地址" class="headerlink" title="在浏览器输入URL地址"></a>在浏览器输入URL地址</h4><ul>
<li><p>输入URL</p>
<p>DNS解析<br>三次握手建立TCP连接<br>发送HTTP请求<br>服务器处理请求并返回HTTP报文<br>浏览器解析渲染页面<br>四次挥手断开连接</p>
</li>
</ul>
<h4 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h4><ol>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>流量控制：</strong> <strong>控制发送方发送速率，保证接收方来得及接收。</strong>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。 当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。将窗口字段设置为 0，则发送方不能发送数据。<br>TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） </li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。拥塞控制窗口的大小取决于网络的拥塞程度。 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong></li>
<li><strong>ARQ协议：</strong>每发完一个分组就停止发送，等待对方确认。如果不能及时收到一个确认，将重发这个报文段，直到收到确认后再发下一个分组。</li>
</ol>
<h4 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP UDP区别"></a>TCP UDP区别</h4><p>UDP 一般用于即时通信，比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 一般用于文件传输、发送和接收邮件、远程登录等场景</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>301  308永久重定向</p>
<p>302 303 307临时重定向</p>
<h4 id="GET-POST区别"><a href="#GET-POST区别" class="headerlink" title="GET POST区别"></a>GET POST区别</h4><p>GET把参数包含在URL中，POST通过request body传递参数。GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<p><a target="_blank" rel="noopener" href="https://www.oschina.net/news/77354/http-get-post-different">https://www.oschina.net/news/77354/http-get-post-different</a></p>
<h4 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h4><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<p>主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>开闭原则：对扩展开放，对修改关闭，在不被修改的前提下被扩展</p>
<p>依赖倒转：针对接口编程，不要针对实现编程。高层模块不应该依赖低层模块，高层底层模块都应该依赖抽象。</p>
<p>里氏代换：能够使用基类对象的地方一定能使用子类对象。</p>
<p>合成复用：尽量使用对象组合/聚合，而不是继承来达到复用的目的</p>
<p>接口分离：如果接口太大，分割为更小的接口</p>
<p>单一职责：</p>
<p>最小知识：</p>
<ul>
<li><p>策略模式</p>
<p> 定义了一族算法； 封装了每个算法； 这族的算法可互换代替，在不同的场景中，该行为有不同的实现算法。符合开闭原则，对扩展开放，对修改关闭。</p>
</li>
<li><p>工厂模式（创建型模式）</p>
<ul>
<li><p>简单工厂</p>
<p>对象的创建和对象本身的业务分离，降低耦合度。</p>
<p>当有新产品要加入到系统中时，必须修改工厂类来加入必要的处理逻辑，违背了开闭原则</p>
</li>
<li><p>工厂方法</p>
<p>核心的工厂类不负责创建产品，而是推迟到子类中完成。</p>
<p>加入新产品时，不需要修改抽象工厂、抽象产品提供的接口和client代码，只要添加一个具体工厂和具体产品就行了</p>
</li>
<li><p>抽象工厂</p>
<p>一个工厂可以生产多个产品对象，针对多个产品等级结构（比如洗衣机是一个产品等级结构，有自己的抽象实现关系，电视机也是一个产品等级结构）。新增具体工厂很方便，但是新增产品等级很麻烦，要改抽象层接口。</p>
</li>
</ul>
</li>
</ul>
<h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成</p>
<h4 id="内核态用户态"><a href="#内核态用户态" class="headerlink" title="内核态用户态"></a>内核态用户态</h4><ol>
<li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制</li>
</ol>
<h4 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h4><p>匿名管道：具有亲缘关系的父子进程间或者兄弟进程之间的通信<br>命名管道：严格遵循**先进先出(first in first out)**。可以实现本机任意两个进程通信。<br>消息队列：读进程可以根据消息类型有选择地接收消息<br>信号量<br>共享内存：多个进程可以访问同一块内存空间<br>套接字：可用于不同机器间的进程通信</p>
<h4 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h4><ol>
<li>**互斥量(Mutex)**：比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步</li>
</ol>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>多级反馈队列<br>优先级</p>
<p>死锁避免：银行家算法<br>死锁预防：互斥、占有等待、不可剥夺、循环等待，破坏条件</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存。页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>页面替换算法：LRU LFU FIFO</p>
<p>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
<p>段页式：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。</p>
<h4 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h4><p>计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备）</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p>
<p>从小到大排序</p>
<h4 id="1-1-冒泡排序-稳定"><a href="#1-1-冒泡排序-稳定" class="headerlink" title="1.1 冒泡排序 稳定"></a>1.1 冒泡排序 稳定</h4><p>一轮，比较相邻两个泡泡，把大的放下面。<br>一轮下来，最大的一定在最下面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(int[] arrs,int n)&#123;</span><br><span class="line">	for(int j&#x3D;N-1;j&gt;&#x3D;0;j--)&#123;</span><br><span class="line">		flag&#x3D;0;</span><br><span class="line">		for(int i&#x3D;0;i&lt;j;i++)&#123;</span><br><span class="line">			if(A[i]&gt;A[i+1])&#123; 严格大于</span><br><span class="line">				swap(A[i],A[i+1]);</span><br><span class="line">				flag&#x3D;1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag&#x3D;&#x3D;0) break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">如果在一趟中，从来没有执行过交换操作，则说明已经有序</span><br></pre></td></tr></table></figure>

<p>最好情况(顺序) T=O(N)<br>最坏情况(逆序) O(N²)    Ω(N²)时间下界</p>
<p>稳定</p>
<h4 id="1-2-插入排序-稳定"><a href="#1-2-插入排序-稳定" class="headerlink" title="1.2 插入排序 稳定"></a>1.2 插入排序 稳定</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arrs==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arrs.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=arrs[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>&amp;&amp;arrs[j-<span class="number">1</span>]&gt;tmp;j--)&#123;</span><br><span class="line">            arrs[j]=arrs[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arrs[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稳定</p>
<h4 id="1-3-希尔排序-不稳定！"><a href="#1-3-希尔排序-不稳定！" class="headerlink" title="1.3 希尔排序 不稳定！"></a>1.3 希尔排序 不稳定！</h4><p>插入排序D间隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void shellSort(int[] arrs,int n)&#123;</span><br><span class="line">	for(int D&#x3D;n&#x2F;2; D&gt;0; D&#x2F;&#x3D;2)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏情况 Θ(N²)</p>
<h4 id="2-1-选择排序-不稳定！"><a href="#2-1-选择排序-不稳定！" class="headerlink" title="2.1 选择排序 不稳定！"></a>2.1 选择排序 不稳定！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void selectionSort(int[] a,int n)&#123;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		minPos&#x3D;findMin(a,i,n-1);</span><br><span class="line">		swap(a[i],a[minPos]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-堆排序-不稳定"><a href="#2-2-堆排序-不稳定" class="headerlink" title="2.2 堆排序* 不稳定"></a>2.2 堆排序* 不稳定</h4><p>O(NlgN)</p>
<p>要从小到大排序的话：</p>
<ol>
<li>建最大堆 O(N)<br>2.将顶上的元素放到数组最后，然后堆规模减一，重新将其调整为最大堆 O(lgN)，重复N次<br>时间复杂度O(NlgN)</li>
</ol>
<p>建堆：<br>方法一：每次插入O(lgN)，插入N次<br>方法二：和删除类似，即已知左边是个堆，右边是个堆，将顶上的元素下滤到合适位置。从下网上建堆，T=树中各个节点的高度和，O(N)<br><img src="C:\Users\99590\AppData\Roaming\Typora\typora-user-images\image-20210329171343653.png" alt="image-20210329171343653" style="zoom:50%;" /></p>
<p>不稳定</p>
<p><a target="_blank" rel="noopener" href="https://xyzghio.xyz/HeapSort/">https://xyzghio.xyz/HeapSort/</a></p>
<h4 id="3-归并排序-稳定-手写补"><a href="#3-归并排序-稳定-手写补" class="headerlink" title="3 归并排序 稳定 手写补"></a>3 归并排序 稳定 手写补</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] tmpA, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> rightEnd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> leftEnd=right-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ptr=left;</span><br><span class="line">	<span class="keyword">int</span> num=rightEnd-left+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;=leftEnd &amp;&amp; right&lt;=rightEnd)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[left]&lt;=a[right]) tmpA[ptr++]=a[left++];</span><br><span class="line">		<span class="keyword">else</span> tmpA[ptr++]=a[right++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;=leftEnd) tmpA[ptr++]=a[left++];</span><br><span class="line">	<span class="keyword">while</span>(right&lt;=rightEnd) tmpA[ptr++]=a[right++];</span><br><span class="line">	tmpA导回到a</span><br><span class="line">&#125;</span><br><span class="line">分而治之递归算法</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] tmpA,<span class="keyword">int</span> left,<span class="keyword">int</span> rightEnd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> center;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;rightEnd)&#123;</span><br><span class="line">		center=(left+rightEnd)/<span class="number">2</span>;</span><br><span class="line">		mergeSort(a,tmpA,left,center);</span><br><span class="line">		mergeSort(a,tmpA,center+<span class="number">1</span>,rightEnd);</span><br><span class="line">		merge(a,tmpA,left,center+<span class="number">1</span>,rightEnd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T(N)=T(N/2)+T(N/2)+O(N)</p>
<p>O(NlgN)</p>
<p>一分为二，左边递归排序，右边递归排序，然后合并</p>
<p>稳定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非递归算法</span><br></pre></td></tr></table></figure>

<h4 id="4-快排-不稳定"><a href="#4-快排-不稳定" class="headerlink" title="4 快排* 不稳定"></a>4 快排* 不稳定</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo==hi) <span class="keyword">return</span>;<span class="comment">//attention</span></span><br><span class="line">    <span class="keyword">int</span> pivot=median3(arr,lo,hi);</span><br><span class="line">    <span class="keyword">if</span>(lo+<span class="number">2</span>&gt;=hi) <span class="keyword">return</span>;<span class="comment">//attention</span></span><br><span class="line">    <span class="keyword">int</span> i=lo,j=hi-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++i]&lt;pivot)&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[--j]&gt;pivot)&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr,i,hi-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr,lo,i-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr,i+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">median3</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[lo]&gt;arr[hi]) swap(arr,lo,hi);</span><br><span class="line">    <span class="keyword">if</span>(arr[lo]&gt;arr[mid]) swap(arr,lo,mid);</span><br><span class="line">    <span class="keyword">if</span>(arr[mid]&gt;arr[hi]) swap(arr,mid,hi);</span><br><span class="line">    swap(arr,mid,hi-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[hi-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=arr[i];</span><br><span class="line">    arr[i]=arr[j];</span><br><span class="line">    arr[j]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于小规模数据，快排效率还不如插入排序</p>
<p>不稳定</p>
<h4 id="5-桶排序"><a href="#5-桶排序" class="headerlink" title="5 桶排序*"></a>5 桶排序*</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设有4万个学生，他们的成绩是0-100间的整数（101个不同的成绩值）。线性时间内将学生按成绩排序。</span><br><span class="line">void bucketSort(int[] a,int n)&#123;</span><br><span class="line">	Person[] cnt&#x3D;new Person[101];</span><br><span class="line">	while(读入某个学生p的成绩score)&#123;</span><br><span class="line">		p.next&#x3D;cnt[score];</span><br><span class="line">		cnt[score]&#x3D;p;&#x2F;&#x2F;插到链表头</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;101;i++)&#123;</span><br><span class="line">		输出链表cnt[i]里的学生</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不稳定</p>
<h4 id="6-基数排序-补attention-稳定！"><a href="#6-基数排序-补attention-稳定！" class="headerlink" title="6 基数排序 *补attention 稳定！"></a>6 基数排序 *补attention 稳定！</h4><h4 id="7-表排序"><a href="#7-表排序" class="headerlink" title="7 表排序"></a>7 表排序</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ckoc7h59h000efour5t1xb137" data-title="计算机基础知识" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/14/SQL/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          SQL语句
        
      </div>
    </a>
  
  
    <a href="/2021/03/20/JAVA-fby/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JAVA基础知识by fby</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 10px;">递归</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/14/SQL/">SQL语句</a>
          </li>
        
          <li>
            <a href="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a>
          </li>
        
          <li>
            <a href="/2021/03/20/JAVA-fby/">JAVA基础知识by fby</a>
          </li>
        
          <li>
            <a href="/2021/03/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找</a>
          </li>
        
          <li>
            <a href="/2021/03/06/BFS%E4%B8%8E%E5%9B%BE/">BFS与图</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>